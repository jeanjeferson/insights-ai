#!/usr/bin/env python3
"""
üß™ TESTE INDIVIDUAL - ENGENHEIRO DE DADOS
Script para testar isoladamente o agente engenheiro_dados e sua task.
"""

import os
import sys
import logging
from datetime import datetime, timedelta
from dotenv import load_dotenv

# Adicionar o diret√≥rio src ao path para importa√ß√µes
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

# Imports do CrewAI
from crewai import Agent, Crew, Process, Task, LLM

# Imports das ferramentas
from insights.tools.sql_query_tool import SQLServerQueryTool

# Load environment
load_dotenv()

# =============== CONFIGURA√á√ÉO DE LOGGING ===============
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('test_engenheiro_individual.log')
    ]
)

logger = logging.getLogger(__name__)

# =============== CONFIGURA√á√ÉO DO LLM ===============
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")

if not OPENROUTER_API_KEY:
    logger.error("‚ùå OPENROUTER_API_KEY n√£o encontrada no ambiente!")
    sys.exit(1)

llm = LLM(
    model="openrouter/deepseek/deepseek-r1",
    base_url="https://openrouter.ai/api/v1",
    api_key=OPENROUTER_API_KEY
)

# =============== CONFIGURA√á√ÉO DOS INPUTS DE TESTE ===============
def get_test_inputs():
    """Gerar inputs de teste padr√£o para o agente"""
    # Usar √∫ltimos 30 dias como padr√£o
    data_fim = datetime.now().strftime('%Y-%m-%d')
    data_inicio = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')
    
    return {
        'data_inicio': data_inicio,
        'data_fim': data_fim
    }

# =============== CONFIGURA√á√ÉO SIMPLIFICADA DOS AGENTES ===============
def create_engenheiro_dados_agent():
    """Criar o agente engenheiro_dados de forma simplificada"""
    logger.info("üîß Criando agente Engenheiro de Dados...")
    
    # Instanciar ferramenta SQL
    sql_tool = SQLServerQueryTool()
    
    return Agent(
        role="Engenheiro de Dados Senior",
        goal="Extrair dados precisos do sistema ERP de joalherias e preparar datasets otimizados para an√°lise",
        backstory="""Voc√™ √© um especialista em engenharia de dados com 12 anos de experi√™ncia em sistemas ERP do varejo de luxo. 
        Com mestrado em Ci√™ncia da Computa√ß√£o e certifica√ß√µes em SQL Server, voc√™ desenvolveu pipelines de ETL 
        que reduziram o tempo de processamento em 75%. Sua especialidade √© garantir a integridade dos dados 
        e otimizar consultas SQL para performance m√°xima, mesmo em sistemas com milh√µes de registros di√°rios.""",
        verbose=True,
        llm=llm,
        tools=[sql_tool],
        allow_delegation=False,
        max_iter=5
    )

# =============== CONFIGURA√á√ÉO SIMPLIFICADA DAS TASKS ===============
def create_engenheiro_dados_task(agent, inputs):
    """Criar a task do engenheiro_dados de forma simplificada"""
    logger.info("üìã Criando task do Engenheiro de Dados...")
    
    data_inicio = inputs['data_inicio']
    data_fim = inputs['data_fim']
    
    description = f"""üîß ENGENHARIA DE DADOS AVAN√áADA COM FILTROS TEMPORAIS:

**IMPORTANTE: Use os inputs data_inicio={data_inicio} e data_fim={data_fim} fornecidos para filtrar os dados!**

1. **Extra√ß√£o Multi-Source com Filtro Temporal**:
   - **OBRIGAT√ìRIO**: Usar SQL Server Query Tool com os par√¢metros:
     * date_start: {data_inicio} 
     * date_end: {data_fim}
     * output_format: "csv"
   - Exemplo de chamada: SQL Server Query Tool com date_start="{data_inicio}", date_end="{data_fim}", output_format="csv"
   - Validar integridade referencial entre fontes

2. **An√°lise de Qualidade dos Dados**:
   - Detectar outliers nos dados filtrados
   - Identificar gaps temporais entre {data_inicio} e {data_fim}
   - Aplicar valida√ß√µes de consist√™ncia no per√≠odo especificado

3. **Transforma√ß√µes B√°sicas**:
   - Criar features derivadas (Preco_Unitario, Margem_Estimada, etc.)
   - Calcular m√©tricas temporais para o per√≠odo analisado
   - Aplicar limpeza b√°sica nos dados

4. **Valida√ß√£o Final**:
   - Gerar relat√≥rio de qualidade de dados para o per√≠odo {data_inicio} a {data_fim}
   - Documentar transforma√ß√µes aplicadas
   - Confirmar que os dados est√£o dentro do range temporal solicitado"""
    
    expected_output = f"""üìã DATASET EMPRESARIAL VALIDADO PARA O PER√çODO {data_inicio} A {data_fim}:

1. **Dados Limpos e Validados**:
   - DataFrame principal com dados filtrados entre {data_inicio} e {data_fim}
   - Outliers identificados e tratados no per√≠odo especificado
   - Campos derivados calculados
   - Metadados de qualidade de dados temporais

2. **Relat√≥rio de Qualidade Temporal**:
   - Estat√≠sticas descritivas por dimens√£o no per√≠odo
   - Gaps identificados entre {data_inicio} e {data_fim}
   - Confirma√ß√£o do range temporal dos dados extra√≠dos
   - Recomenda√ß√µes para coleta futura

3. **Features Engineered Temporais**:
   - Campos calculados otimizados para an√°lise temporal
   - Segmenta√ß√µes autom√°ticas (pre√ßo, frequ√™ncia, etc.) no per√≠odo
   - M√©tricas de evolu√ß√£o temporal quando aplic√°vel

**VALIDA√á√ÉO CR√çTICA**: Confirmar que todos os dados est√£o dentro do per√≠odo {data_inicio} a {data_fim}"""
    
    return Task(
        description=description,
        expected_output=expected_output,
        agent=agent,
        output_file=f'output/teste_engenheiro_dados_{data_inicio}_{data_fim}.md'
    )

# =============== FUN√á√ÉO PRINCIPAL DE TESTE ===============
def test_engenheiro_dados():
    """Fun√ß√£o principal para testar o agente engenheiro_dados"""
    logger.info("üöÄ INICIANDO TESTE INDIVIDUAL - ENGENHEIRO DE DADOS")
    logger.info("=" * 60)
    
    try:
        # 1. Preparar inputs de teste
        logger.info("üìã Preparando inputs de teste...")
        inputs = get_test_inputs()
        logger.info(f"üìÖ Per√≠odo de teste: {inputs['data_inicio']} at√© {inputs['data_fim']}")
        
        # 2. Criar agente
        logger.info("üîß Criando agente...")
        agent = create_engenheiro_dados_agent()
        logger.info("‚úÖ Agente criado com sucesso")
        
        # 3. Criar task
        logger.info("üìã Criando task...")
        task = create_engenheiro_dados_task(agent, inputs)
        logger.info("‚úÖ Task criada com sucesso")
        
        # 4. Criar crew m√≠nimo
        logger.info("üöÄ Criando crew m√≠nimo...")
        crew = Crew(
            agents=[agent],
            tasks=[task],
            process=Process.sequential,
            verbose=True,
            memory=False,
            max_rpm=10  # Limite conservador para testes
        )
        logger.info("‚úÖ Crew criado com sucesso")
        
        # 5. Executar teste
        logger.info("üéØ Executando teste...")
        logger.info("‚è∞ Iniciando execu√ß√£o...")
        start_time = datetime.now()
        
        result = crew.kickoff(inputs=inputs)
        
        end_time = datetime.now()
        execution_time = end_time - start_time
        
        # 6. Exibir resultados
        logger.info("‚úÖ TESTE CONCLU√çDO COM SUCESSO!")
        logger.info("=" * 60)
        logger.info(f"‚è±Ô∏è Tempo de execu√ß√£o: {execution_time}")
        logger.info(f"üìä Tipo do resultado: {type(result)}")
        logger.info(f"üìù Tamanho do output: {len(str(result))} caracteres")
        
        # Salvar resultado completo
        result_file = f'output/resultado_teste_engenheiro_{inputs["data_inicio"]}_{inputs["data_fim"]}.txt'
        os.makedirs('output', exist_ok=True)
        
        with open(result_file, 'w', encoding='utf-8') as f:
            f.write(f"TESTE INDIVIDUAL - ENGENHEIRO DE DADOS\n")
            f.write(f"Data/Hora: {datetime.now()}\n")
            f.write(f"Per√≠odo: {inputs['data_inicio']} at√© {inputs['data_fim']}\n")
            f.write(f"Tempo de execu√ß√£o: {execution_time}\n")
            f.write("\n" + "="*60 + "\n")
            f.write("RESULTADO:\n")
            f.write(str(result))
        
        logger.info(f"üíæ Resultado salvo em: {result_file}")
        
        # Exibir preview do resultado
        logger.info("\nüìã PREVIEW DO RESULTADO:")
        logger.info("-" * 40)
        preview = str(result)[:500] + "..." if len(str(result)) > 500 else str(result)
        logger.info(preview)
        
        return True
        
    except Exception as e:
        logger.error(f"‚ùå ERRO NO TESTE: {e}")
        logger.exception("Detalhes do erro:")
        return False

# =============== FUN√á√ÉO DE VALIDA√á√ÉO DE FERRAMENTAS ===============
def validate_tools():
    """Validar se as ferramentas necess√°rias est√£o funcionando"""
    logger.info("üîß Validando ferramentas...")
    
    try:
        # Testar SQL Tool
        sql_tool = SQLServerQueryTool()
        logger.info("‚úÖ SQLServerQueryTool instanciada com sucesso")
        
        # Verificar se tem m√©todo _run
        if hasattr(sql_tool, '_run'):
            logger.info("‚úÖ M√©todo _run encontrado")
        else:
            logger.warning("‚ö†Ô∏è M√©todo _run n√£o encontrado")
            
        # Listar m√©todos dispon√≠veis
        methods = [method for method in dir(sql_tool) 
                  if not method.startswith('_') and callable(getattr(sql_tool, method))]
        logger.info(f"üîß M√©todos dispon√≠veis: {methods[:5]}")
        
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Erro na valida√ß√£o de ferramentas: {e}")
        return False

# =============== MENU INTERATIVO ===============
def interactive_menu():
    """Menu interativo para diferentes op√ß√µes de teste"""
    print("\nüß™ TESTE INDIVIDUAL - ENGENHEIRO DE DADOS")
    print("=" * 50)
    print("1. Executar teste com per√≠odo padr√£o (√∫ltimos 30 dias)")
    print("2. Executar teste com per√≠odo customizado")
    print("3. Validar apenas as ferramentas")
    print("4. Sair")
    
    choice = input("\nEscolha uma op√ß√£o (1-4): ").strip()
    
    if choice == "1":
        return test_engenheiro_dados()
        
    elif choice == "2":
        print("\nüìÖ Digite o per√≠odo para an√°lise:")
        data_inicio = input("Data in√≠cio (YYYY-MM-DD): ").strip()
        data_fim = input("Data fim (YYYY-MM-DD): ").strip()
        
        # Validar formato
        try:
            datetime.strptime(data_inicio, '%Y-%m-%d')
            datetime.strptime(data_fim, '%Y-%m-%d')
            
            # Atualizar inputs globais para o teste
            inputs = {'data_inicio': data_inicio, 'data_fim': data_fim}
            
            # Executar teste customizado
            logger.info(f"üìÖ Per√≠odo customizado: {data_inicio} at√© {data_fim}")
            agent = create_engenheiro_dados_agent()
            task = create_engenheiro_dados_task(agent, inputs)
            
            crew = Crew(
                agents=[agent],
                tasks=[task],
                process=Process.sequential,
                verbose=True,
                memory=False,
                max_rpm=10
            )
            
            result = crew.kickoff(inputs=inputs)
            logger.info("‚úÖ Teste customizado conclu√≠do!")
            return True
            
        except ValueError:
            logger.error("‚ùå Formato de data inv√°lido! Use YYYY-MM-DD")
            return False
            
    elif choice == "3":
        return validate_tools()
        
    elif choice == "4":
        logger.info("üëã Saindo...")
        return True
        
    else:
        logger.error("‚ùå Op√ß√£o inv√°lida!")
        return False

# =============== ENTRY POINT ===============
if __name__ == "__main__":
    # Verificar se o diret√≥rio existe
    if not os.path.exists('src/insights'):
        logger.error("‚ùå Diret√≥rio src/insights n√£o encontrado!")
        logger.error("Execute este script a partir do diret√≥rio raiz do projeto")
        sys.exit(1)
    
    # Criar diret√≥rio de output se n√£o existir
    os.makedirs('output', exist_ok=True)
    
    try:
        # Executar valida√ß√£o inicial
        if not validate_tools():
            logger.error("‚ùå Falha na valida√ß√£o de ferramentas!")
            sys.exit(1)
            
        # Menu interativo ou execu√ß√£o direta
        if len(sys.argv) > 1 and sys.argv[1] == "--auto":
            # Execu√ß√£o autom√°tica para CI/CD
            success = test_engenheiro_dados()
            sys.exit(0 if success else 1)
        else:
            # Menu interativo
            interactive_menu()
            
    except KeyboardInterrupt:
        logger.info("\nüëã Teste interrompido pelo usu√°rio")
    except Exception as e:
        logger.error(f"‚ùå Erro inesperado: {e}")
        sys.exit(1) 