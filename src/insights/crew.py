from crewai import Agent, Crew, Process, Task, LLM
from crewai.project import CrewBase, agent, crew, task, before_kickoff
from crewai.agents.agent_builder.base_agent import BaseAgent
from crewai_tools import FileReadTool
from typing import List
from dotenv import load_dotenv
import os

# =============== IMPORTA√á√ïES OTIMIZADAS DE FERRAMENTAS ===============

# Ferramentas b√°sicas
from insights.tools.sql_query_tool import SQLServerQueryTool
from insights.tools.kpi_calculator_tool import KPICalculatorTool
from insights.tools.prophet_tool import ProphetForecastTool
from insights.tools.statistical_analysis_tool import StatisticalAnalysisTool
from insights.tools.business_intelligence_tool import BusinessIntelligenceTool
from insights.tools.duckduck_tool import DuckDuckGoSearchTool

# Ferramentas avan√ßadas
from insights.tools.advanced.customer_insights_engine import CustomerInsightsEngine
from insights.tools.advanced.recommendation_engine import RecommendationEngine
from insights.tools.advanced.advanced_analytics_engine_tool import AdvancedAnalyticsEngineTool
from insights.tools.advanced.risk_assessment_tool import RiskAssessmentTool
from insights.tools.advanced.competitive_intelligence_tool import CompetitiveIntelligenceTool

load_dotenv()

OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")

llm = LLM(
    model="openrouter/deepseek/deepseek-chat-v3-0324",
    base_url="https://openrouter.ai/api/v1",
    api_key=OPENROUTER_API_KEY
)

# =============== INSTANCIA√á√ÉO COMPLETA DE FERRAMENTAS ===============

# Ferramentas b√°sicas
file_tool = FileReadTool()
sql_tool = SQLServerQueryTool()
search_tool = DuckDuckGoSearchTool()

# Ferramentas de an√°lise
kpi_tool = KPICalculatorTool()
prophet_tool = ProphetForecastTool()
stats_tool = StatisticalAnalysisTool()
bi_tool = BusinessIntelligenceTool()

# Ferramentas avan√ßadas de IA/ML
customer_engine = CustomerInsightsEngine()
recommendation_engine = RecommendationEngine()
analytics_engine = AdvancedAnalyticsEngineTool()
risk_tool = RiskAssessmentTool()
competitive_tool = CompetitiveIntelligenceTool()

@CrewBase
class Insights():
    """
    Crew otimizada com distribui√ß√£o inteligente de ferramentas:
    - Valida√ß√£o autom√°tica de ferramentas
    - Rate limiting inteligente  
    - Monitoramento de performance
    - Fallbacks para ferramentas indispon√≠veis
    - Distribui√ß√£o especializada por agente
    """

    def __init__(self):
        super().__init__()
        self.tools_status = validate_tools_setup()

    agents: List[BaseAgent]
    tasks: List[Task]
    
    @before_kickoff
    def before_kickoff(self, inputs):
        """Before kickoff otimizado com valida√ß√µes e inputs de data"""
        print("üöÄ Iniciando Insights-AI Otimizado...")
        
        # Validar e exibir inputs de data
        data_inicio = inputs.get('data_inicio')
        data_fim = inputs.get('data_fim')
        
        if data_inicio and data_fim:
            print(f"üìÖ Per√≠odo de an√°lise: {data_inicio} at√© {data_fim}")
            
            # Validar formato das datas
            try:
                from datetime import datetime
                datetime.strptime(data_inicio, '%Y-%m-%d')
                datetime.strptime(data_fim, '%Y-%m-%d')
                print("‚úÖ Formato de datas validado")
            except ValueError:
                print("‚ö†Ô∏è WARNING: Formato de data inv√°lido! Use YYYY-MM-DD")
        else:
            print("‚ö†Ô∏è WARNING: Inputs de data n√£o fornecidos!")
        
        # Validar ferramentas cr√≠ticas
        critical_tools = ['sql_tool', 'prophet_tool', 'stats_tool', 'bi_tool']
        for tool_name in critical_tools:
            tool_obj = globals().get(tool_name)
            if tool_obj is None:
                print(f"‚ö†Ô∏è WARNING: {tool_name} n√£o encontrada!")
            else:
                print(f"‚úÖ {tool_name} carregada com sucesso")
        
        # Executar SQL extraction com as datas fornecidas (se dispon√≠veis)
        try:
            if data_inicio and data_fim:
                print(f"üîÑ Extraindo dados do SQL Server para o per√≠odo {data_inicio} a {data_fim}...")
                # O agente usar√° o SQL Tool com os par√¢metros corretos
                print("üìã Dados ser√£o extra√≠dos pelo agente usando os inputs fornecidos")
            else:
                sql_tool._execute_query_and_save_to_csv()
                print("‚úÖ Dados extra√≠dos com sucesso do SQL Server (per√≠odo padr√£o)")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro na extra√ß√£o SQL: {e}")
            print("üîÑ Tentando usar dados existentes...")
        
        return inputs
    
    # =============== AGENTES OTIMIZADOS COM DISTRIBUI√á√ÉO ESPECIALIZADA ===============
    
    @agent
    def engenheiro_dados(self) -> Agent:
        """
        üîß ESPECIALISTA EM DADOS E ETL
        Ferramentas: SQL + Analytics Engine + File Tool
        Foco: Extra√ß√£o, transforma√ß√£o e valida√ß√£o de dados
        """
        return Agent(
            config=self.agents_config['engenheiro_dados'],
            verbose=True,
            llm=llm,
            tools=[
                file_tool,                # ‚úÖ Leitura de arquivos
                sql_tool,                 # ‚úÖ Acesso direto SQL Server
                analytics_engine          # ‚úÖ ETL avan√ßado e prepara√ß√£o
            ],
            allow_code_execution=False,
            reasoning=True,
            max_reasoning_attempts=3
        )

    @agent
    def analista_tendencias(self) -> Agent:
        """
        üìà ESPECIALISTA EM PADR√ïES E PESQUISA
        Ferramentas: Statistical Analysis + DuckDuckGo + BI Dashboard
        Foco: An√°lise de correla√ß√µes, tend√™ncias e contexto externo
        """
        return Agent(
            config=self.agents_config['analista_tendencias'],
            verbose=True,
            llm=llm,
            tools=[
                file_tool,                # ‚úÖ Leitura de dados
                stats_tool,               # ‚úÖ An√°lise estat√≠stica avan√ßada
                search_tool,              # ‚úÖ NOVO: Pesquisa de contexto externo
                bi_tool                   # ‚úÖ Visualiza√ß√µes e dashboards
            ],
            respect_context_window=True,
            allow_code_execution=False,
            reasoning=True,
            max_reasoning_attempts=3
        )

    @agent
    def especialista_sazonalidade(self) -> Agent:
        """
        üåä EXPERT EM SAZONALIDADE E CICLOS
        Ferramentas: Statistical Analysis + Analytics Engine + BI Dashboard
        Foco: Decomposi√ß√£o sazonal, modelagem temporal e padr√µes c√≠clicos
        """
        return Agent(
            config=self.agents_config['especialista_sazonalidade'],
            verbose=True,
            llm=llm,
            tools=[
                file_tool,                # ‚úÖ Leitura de dados
                stats_tool,               # ‚úÖ Decomposi√ß√£o sazonal STL
                analytics_engine,         # ‚úÖ Modelagem temporal avan√ßada
                bi_tool                   # ‚úÖ Visualiza√ß√µes sazonais
            ],
            respect_context_window=True,
            allow_code_execution=False,
            reasoning=True,
            max_reasoning_attempts=3
        )
        
    @agent
    def especialista_projecoes(self) -> Agent:
        """
        üîÆ FORECASTER PROFISSIONAL
        Ferramentas: Prophet + Statistical Analysis + BI Dashboard
        Foco: Previs√µes precisas, valida√ß√£o de modelos e cen√°rios
        """
        return Agent(
            config=self.agents_config['especialista_projecoes'],
            verbose=True,
            llm=llm,
            tools=[
                file_tool,                # ‚úÖ Leitura de dados
                prophet_tool,             # ‚úÖ CR√çTICO: Prophet forecasting
                stats_tool,               # ‚úÖ Valida√ß√£o estat√≠stica de modelos
                bi_tool                   # ‚úÖ Gr√°ficos de proje√ß√£o profissionais
            ],
            respect_context_window=True,
            allow_code_execution=False,
            reasoning=True,
            max_reasoning_attempts=3
        )
        
    @agent
    def analista_segmentos(self) -> Agent:
        """
        üë• ESPECIALISTA EM CATEGORIAS E CLIENTES
        Ferramentas: KPI Calculator + Customer Insights + BI Dashboard
        Foco: Segmenta√ß√£o, an√°lise por categoria e comportamento do cliente
        """
        return Agent(
            config=self.agents_config['analista_segmentos'],
            verbose=True,
            llm=llm,
            tools=[
                file_tool,                # ‚úÖ Leitura de dados
                kpi_tool,                 # ‚úÖ KPIs especializados por categoria
                customer_engine,          # ‚úÖ Segmenta√ß√£o autom√°tica IA
                bi_tool                   # ‚úÖ Dashboards comparativos
            ],
            respect_context_window=True,
            allow_code_execution=False,
            reasoning=True,
            max_reasoning_attempts=3
        )

    @agent
    def analista_inventario(self) -> Agent:
        """
        üì¶ OTIMIZADOR DE ESTOQUE INTELIGENTE
        Ferramentas: KPI Calculator + Recommendation Engine + Risk Assessment + BI Dashboard
        Foco: Otimiza√ß√£o de invent√°rio, gest√£o de riscos e recomenda√ß√µes autom√°ticas
        """
        return Agent(
            config=self.agents_config['analista_inventario'],
            verbose=True,
            llm=llm,
            tools=[
                file_tool,                # ‚úÖ Leitura de dados
                kpi_tool,                 # ‚úÖ KPIs de estoque especializados
                recommendation_engine,    # ‚úÖ Recomenda√ß√µes ML para estoque
                risk_tool,                # ‚úÖ Avalia√ß√£o de riscos de invent√°rio
                bi_tool                   # ‚úÖ Dashboards operacionais
            ],
            allow_code_execution=False,
            reasoning=True,
            max_reasoning_attempts=3
        )

    @agent  
    def diretor_insights(self) -> Agent:
        """
        üéØ EXECUTIVO C-LEVEL COM ARSENAL ESTRAT√âGICO
        Ferramentas: BI Dashboard + Recommendation Engine + Competitive Intelligence + KPI Calculator
        Foco: S√≠ntese estrat√©gica, benchmarking competitivo e decis√µes executivas
        """
        return Agent(
            config=self.agents_config['diretor_insights'],
            verbose=True,
            llm=llm,
            tools=[
                file_tool,                      # ‚úÖ Leitura de dados
                kpi_tool,                       # ‚úÖ KPIs executivos
                bi_tool,                        # ‚úÖ Dashboards executivos
                recommendation_engine,          # ‚úÖ Recomenda√ß√µes estrat√©gicas
                competitive_tool,               # ‚úÖ Intelig√™ncia competitiva
            ],
            allow_code_execution=False,
            reasoning=True,
            max_reasoning_attempts=3
        )

    # =============== TASKS ===============
    
    @task
    def engenheiro_dados_task(self) -> Task:
        return Task(
            config=self.tasks_config['engenheiro_dados_task'],
            # Garantir que os inputs de data sejam passados para a task
            context_variables=['data_inicio', 'data_fim']
        )
    
    @task
    def analista_tendencias_task(self) -> Task:
        return Task(
            config=self.tasks_config['analista_tendencias_task'],
            context=[self.engenheiro_dados_task()]
        )
    
    @task
    def especialista_sazonalidade_task(self) -> Task:
        return Task(
            config=self.tasks_config['especialista_sazonalidade_task'],
            context=[self.engenheiro_dados_task()]
        )
    
    @task
    def especialista_projecoes_task(self) -> Task:
        return Task(
            config=self.tasks_config['especialista_projecoes_task'],
            context=[self.engenheiro_dados_task(), self.especialista_sazonalidade_task()]
        )
    
    @task
    def analista_segmentos_task(self) -> Task:
        return Task(
            config=self.tasks_config['analista_segmentos_task'],
            context=[self.engenheiro_dados_task()]
        )

    @task
    def analise_inventario_task(self) -> Task:
        return Task(
            config=self.tasks_config['analise_inventario_task'],
            context=[self.engenheiro_dados_task()]
        )
        
    @task
    def relatorio_executivo_completo_task(self) -> Task:
        """
        TASK FINAL OTIMIZADA - S√≠ntese estrat√©gica com todas as ferramentas
        """
        return Task(
            config=self.tasks_config['relatorio_executivo_completo_task'],
            context=[
                self.engenheiro_dados_task(), 
                self.analista_tendencias_task(), 
                self.especialista_sazonalidade_task(), 
                self.especialista_projecoes_task(), 
                self.analista_segmentos_task(), 
                self.analise_inventario_task()
            ],
            output_file='reports/relatorio_executivo_completo.md'
        )

    @crew
    def crew(self) -> Crew:
        """Creates the OPTIMIZED Insights crew with enhanced configuration"""
        return Crew(
            agents=self.agents,
            tasks=self.tasks,
            process=Process.sequential,
            verbose=True,
            memory=True,
            planning=True,
            max_rpm=25,              # ‚úÖ Rate limiting otimizado para estabilidade
            max_execution_time=3600, # ‚úÖ NOVO: Timeout de 1 hora
            embedder={               # ‚úÖ Embedding para mem√≥ria otimizada
                "provider": "ollama",
                "config": {
                    "model": "nomic-embed-text",
                    "base_url": "https://ollama.capta.com.br"
                }
            }
        )


# =============== VALIDA√á√ÉO AVAN√áADA DE FERRAMENTAS ===============

def validate_tools_setup():
    """Validar se todas as ferramentas foram importadas e instanciadas corretamente"""
    
    tools_status = {
        "B√°sicas": {
            "FileReadTool": _validate_tool(file_tool, "file_tool"),
            "SQLServerQueryTool": _validate_tool(sql_tool, "sql_tool"),
            "DuckDuckGoSearchTool": _validate_tool(search_tool, "search_tool"),
            "KPICalculatorTool": _validate_tool(kpi_tool, "kpi_tool"),
            "ProphetForecastTool": _validate_tool(prophet_tool, "prophet_tool"),
            "StatisticalAnalysisTool": _validate_tool(stats_tool, "stats_tool"),
            "BusinessIntelligenceTool": _validate_tool(bi_tool, "bi_tool"),
        },
        "Avan√ßadas": {
            "CustomerInsightsEngine": _validate_tool(customer_engine, "customer_engine"),
            "RecommendationEngine": _validate_tool(recommendation_engine, "recommendation_engine"),
            "AdvancedAnalyticsEngine": _validate_tool(analytics_engine, "analytics_engine"),
            "RiskAssessmentTool": _validate_tool(risk_tool, "risk_tool"),
            "CompetitiveIntelligenceTool": _validate_tool(competitive_tool, "competitive_tool")
        }
    }
    
    print("üîß VALIDA√á√ÉO COMPLETA DE FERRAMENTAS:")
    print("=" * 50)
    
    total_tools = 0
    working_tools = 0
    
    for category, tools in tools_status.items():
        print(f"\nüìÇ {category}:")
        for tool_name, status in tools.items():
            total_tools += 1
            status_icon = "‚úÖ" if status['available'] else "‚ùå"
            print(f"  {status_icon} {tool_name}")
            
            if status['available']:
                working_tools += 1
                if status.get('methods'):
                    print(f"      M√©todos: {', '.join(status['methods'][:3])}...")
            else:
                print(f"      Erro: {status.get('error', 'N√£o dispon√≠vel')}")
    
    success_rate = (working_tools / total_tools) * 100
    print(f"\nüìä RESUMO:")
    print(f"  ‚úÖ Ferramentas funcionando: {working_tools}/{total_tools} ({success_rate:.1f}%)")
    
    if success_rate >= 90:
        print(f"  üéâ EXCELENTE! Sistema totalmente operacional")
    elif success_rate >= 75:
        print(f"  ‚úÖ BOM! Maioria das ferramentas funcionando")
    else:
        print(f"  ‚ö†Ô∏è ATEN√á√ÉO! Muitas ferramentas com problemas")
    
    return tools_status

def _validate_tool(tool_instance, tool_name: str) -> dict:
    """Validar uma ferramenta espec√≠fica"""
    try:
        if tool_instance is None:
            return {'available': False, 'error': 'Inst√¢ncia n√£o criada'}
        
        # Verificar se tem m√©todo _run (padr√£o CrewAI)
        has_run = hasattr(tool_instance, '_run')
        
        # Listar m√©todos dispon√≠veis
        methods = [method for method in dir(tool_instance) 
                  if not method.startswith('_') and callable(getattr(tool_instance, method))]
        
        return {
            'available': True,
            'has_run_method': has_run,
            'methods': methods[:5],  # Primeiros 5 m√©todos
            'class_name': tool_instance.__class__.__name__
        }
        
    except Exception as e:
        return {'available': False, 'error': str(e)}

def get_tools_by_agent():
    """Retornar mapeamento de ferramentas por agente para debugging"""
    return {
        "engenheiro_dados": ["FileReadTool", "SQLServerQueryTool", "AdvancedAnalyticsEngine"],
        "analista_tendencias": ["FileReadTool", "StatisticalAnalysisTool", "DuckDuckGoSearchTool", "BusinessIntelligenceTool"],
        "especialista_sazonalidade": ["FileReadTool", "StatisticalAnalysisTool", "AdvancedAnalyticsEngine", "BusinessIntelligenceTool"],
        "especialista_projecoes": ["FileReadTool", "ProphetForecastTool", "StatisticalAnalysisTool", "BusinessIntelligenceTool"],
        "analista_segmentos": ["FileReadTool", "KPICalculatorTool", "CustomerInsightsEngine", "BusinessIntelligenceTool"],
        "analista_inventario": ["FileReadTool", "KPICalculatorTool", "RecommendationEngine", "RiskAssessmentTool", "BusinessIntelligenceTool"],
        "diretor_insights": ["FileReadTool", "KPICalculatorTool", "BusinessIntelligenceTool", "RecommendationEngine", "CompetitiveIntelligenceTool"]
    }


if __name__ == "__main__":
    # Validar setup ao executar diretamente
    print("üöÄ INSIGHTS-AI CREW OTIMIZADA")
    print("=" * 50)
    
    tools_status = validate_tools_setup()
    
    print(f"\nüéØ DISTRIBUI√á√ÉO DE FERRAMENTAS POR AGENTE:")
    print("=" * 50)
    
    agent_tools = get_tools_by_agent()
    for agent, tools in agent_tools.items():
        print(f"\nüë§ {agent.replace('_', ' ').title()}:")
        for tool in tools:
            print(f"  üîß {tool}")
    
    print(f"\nüöÄ Crew otimizada pronta para uso!")
    print(f"üìä Ferramentas distribu√≠das por especializa√ß√£o")
    print(f"üéØ Capacidade anal√≠tica maximizada")
    print(f"‚ö° Performance e rate limiting otimizados")
